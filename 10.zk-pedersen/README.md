# On-chain ZK based Pedersen shared secret

The main target of this tutorial is to show how to build an on-chain ocean condition in which 
uses the zero-knowledge proofs (mainly ZKSNARKS) to verify a particular user is authorized to 
access a resource using a shared (secret) token. 


### Get started

We are going to build the hash algorithm circuit, compile the circuit, and generate constraints using 
[circom](https://github.com/iden3/circom) (A zero-knowledge circuit compiler). Also, we are going to use [snarkJs](https://github.com/iden3/snarkjs) in order 
to generate the witness by calculating all the signals of the circuit that match (all) the constrains of the circuit, then create proofs, and 
finally generate and deploy on-chain verification solidity contract.

- Install circom and snarkJs (`Node-10` recommended)

```
npm install -g circom
npm install -g snarkjs
```

### Shared token condition

In this proof of concept, we are going to use [Pedersen hash function](docs/26_04_2019_Non-Intera.pdf) as a commitment scheme. Using this hash function, the proof of having the right pre-image for a particular commitment will be created off-chain and verified on-chain 
without exposing any prior knowledge about the pre-image. The advantage of having this scenario is to avoid the [front-running](https://en.wikipedia.org/wiki/Front_running) attack on an Ethereum network.

#### Create Pedersen circuit

We are NOT going to create the Pedersen circuit from scratch but we are 
going to use pre-defined Pedersen template [here](/pedersen/pedersen.circom).


The Pederson scheme simplified (originally from this [stackoverflow thread](https://crypto.stackexchange.com/questions/64437/what-is-a-pedersen-commitment)). In a commitment scheme such as Pedersen

- The committer (or sender) decides (or is given) a secret message `m` taken in some public message space with at least two elements;
- Decides a random secret `r`;
- Produces from that `m` and `r` a commitment `c= C(m,r)` by applying some public method (the commitment algorithm `C`) defined by the scheme;
- Makes `c` public;
- Later reveals `m` and `r`.
- The verifier (or receiver) is given `c`, `m`, `r` and can check if indeed `C(m,r)=c`. That will always hold if 1,2,3,4,5 steps are carried out as stated.

#### Compile PedersenHash circuit
Compile the PedersenHash circuit by running the following command(s):
```bash
cd pedersen/
circom pedersen.circom -o pedersen.json
```

Please do note that in this proof of concept, we assume that we have only `3` actors are going to share the secret.

```javascript
component main = Pedersen(3);
```
For more info about the compiled circuit check out [pedersen.json](pedersen/pedersen.json).

#### Taking the compiled circuit to snarkjs

Now we are going to use the compiled version of Pedersen circuit in creating proofs, and generating the on-chain verification contract.

**Get some info about the circuit**

```bash
snarkjs info -c pedersen.json
# Wires: 48
# Constraints: 5
# Private Inputs: 0
# Public Inputs: 3
# Outputs: 2
```

**Printing circuit constraints**

```bash
snarkjs printconstraints -c pedersen.json

[  -1main.in[1] ] * [  1main.in[0] ] - [  -8512718354600743731260140871119600659042431671587320581600472088012772122510main.segments[0].windows[0].mux.a10[1] ] = 0
[  10110152377307078249629074015645599638501379999221929487419104864320262287456 -3387841432138222531662561953325891569424841883155741469979160223447762318178main.in[0] -7060542524143950543792169769989171266650502314219888923702386659082613693201main.in[1] -9671720741459206139935677197606883048516199483872149599876248640770473317054main.segments[0].windows[0].mux.a10[1] ] * [  1main.in[2] ] - [  2222895596481192187822725317585512278677338478070452460398878218688982945387 +84666901775536267764185358772101759379253483353673264996197110437682243474718466690177553626776418535877210175937925348335367326499619711043768224347471main.in[0] -2614822068362687435165702331614778442955498029275004934983549247234479261439main.in[1] -1main.segments[0].windows[0].out[0] +65815160820448285906908248876449519062054509835003919093813605185810555876606581516082044828590690824887644951906205450983500391909381360518581055587660main.segments[0].windows[0].mux.a10[1] ] = 0
[  -7253076032401735217863724344638466922376918894540507490866253503969473386213 +32210893512783759023079475684336990452627202712225220027231303242207448705503221089351278375902307947568433699045262720271222522002723130324220744870550main.in[0] +12982500199254537552128668251975229656478678598898082297316133378069592983781298250019925453755212866825197522965647867859889808229731613337806959298378main.in[1] -7080263708377326332008830638474772886536670324487307031213364513731374852847main.segments[0].windows[0].mux.a10[1] ] * [  1main.in[2] ] - [  645990683923994438773785240289155268877156315898516408299891108873795692262 -5058307044111445630228617509474658062867038899923023456712838198595069393152main.in[0] +82322087736293534287194119198853847737454300840372244447472091328283312280578232208773629353428719411919885384773745430084037224444747209132828331228057main.in[1] -1main.segments[0].windows[0].out[1] +11main.segments[0].windows[0].mux.a10[1] ] = 0
[  1main.out[0] ] * [  1main.segments[0].windows[0].out[1] ] - [  1main.segments[0].windows[0].out[0] ] = 0
[  1main.out[1] ] * [  1 +11main.segments[0].windows[0].out[0] ] - [  -1 +11main.segments[0].windows[0].out[0] ] = 0

```

**Setup the circuit**

The following command will setup the circuit, generate `proving_key.json` and `verification_key.json`. These keys will be used during the 
proof generation and verification contract creation respectively.
```bash
snarkjs setup -c pedersen.json
```

**Calculating a witness**

`The zero knowledge proofs prove that you know a set of signals (witness) that match all the constraints but without revealing any of the signals except the public inputs plus the outputs.`

This means that `snarkjs` will calculate all the signals of the circuit that match (all) the constrains of the circuit. 

As mentioned before, this proof of concept uses only `3` actors. Also you can notice from the circuit info [here]() that 
we have `3` public inputs. So lets prepare our `input.json` file where it will be used to calculate the witness.

So what we are going to do is to generate new `input.json` file and add sample inputs `{"in": [123, 123, 123]}`. Finally use 
the following command to calculate the witness:

```bash
snarkjs calculatewitness -c pedersen.json
cat witness.json 
[
 "1",
 "3869853062105997851476306317640809714924295844228071859163978885754207866410",
 "16198016942030475297217214056085330459574873239101512189096323031942145517371",
 "123",
 "123",
 "123",
 "2222895596481192187822725317585512278677338478070452460398878218688982945387",
 "645990683923994438773785240289155268877156315898516408299891108873795692262",
 "11807072774519778391727937927031813251595598506795465728818673786606575968932",
 "20556566955901383908112117822462520047375924518148366762418286401085197373331",
 "14582557693464339055546547842386903141088202080615684406083333604631902875191",
 "9998200852771784303845953440744768525625859184821078429689061501259050089107",
 "10689585774034818964241261194795688216602686813437778960018589262457207292858",
 "21496316399957779974903428731228008924270204849211481869113533158030312179565",
 "20148122448084665472690189271556564634946792286428273056429609293634905073159",
 "14000986091013389160440057047197187728724322879264557316677977540944529153548",
 "3967274828865963246274749132475980147526148697371590942578644621584707323580",
 "18446706546794652269066524485571580552419327164209441305396814952792663585310",
 "17475926511651824030791573476071772294558481816391527295285257096854534794727",
 "8878199457553347867493197160174540042622586399935740853047100241702126920319",
 "9629830623104249603835073664239053722879479132263621850643030749674544917317",
 "7899066716325729656637509584927622191254075210439023899166144612843269078475",
 "21507913192775183346347350252276540171672680439709512783428380276603263310390",
 "14833025470029629330144054679615483999351637434586440114181740407864641008154",
 "20556566955901383908112117822462520047375924518148366762418286401085197373331",
 "7384429010954197105055205155822179682759540491841454699081092988643688324038",
 "1648352834234242409588883461995754952441489917082993826230687036399146039940",
 "14805258467974183218827057643634337344625573032820998211163595790704952934660",
 "15421190523883389886788626462762875933699168436881862492597192942350474264442",
 "827881588055142171813411099196436356836628020251548277170827939134403719171",
 "19682624357705993238804158242543244115104330247534446195320849665788742339073",
 "11778090494532196972617331729611675450046984401194104856279099322255546208161",
 "7253076032401735217863724344638466922376918894540507490866253503969473386213",
 "457648460474303299487504143321782665600464302928247806924676122704568560595",
 "17260043546963291525684863626169821200278596653555599289071952557645615677095",
 "6700528668978573808314699390241377844699208405414908152496505388796178277258",
 "5702507051803811509153001864067673097463137917441026893789330755397550252629",
 "12655476862650158053898842869759711203044718430627545299408861614428595444934",
 "12587276857631168927025812947078035835256782921533110791568822983504911015197",
 "15129",
 "8098712805945627450947576143286326767038011039420963227064456579643806989636",
 "1497127478735981924638465535983209662792700200320344548841629208502610536530",
 "14101937781114236551582068002925900549867400070484526415766281669487307553322",
 "16304146532825200933857046466212474810220803785975769096222851795922217490741",
 "9284689302511292402500061960492128919464243805778491941621827786601105066921",
 "17344488349165948329931794404595337397348529571892900828957802367920042111472",
 "18991607767915291382093480082641315004821845853059618046548200610910738896112",
 "8133572064185759733512378612131650354474688056747988016381921261636045165032"
]
```

**Creating Proof**

`snarkJs` will use the calculated witness to generate the proof. 

```bash
snarkjs proof -c pedersen.json
```

This command will use the [prooving_key.json](pedersen/proving_key.json) and the [witness.json](pedersen/witness.json) files by default to generate [proof.json](pedersen/proof.json) and [public.json](pedersen/proof.json).
The `proof.json` file will contain the actual proof. And the `public.json` file will contain just the values of the public inputs and the outputs.

**Verifying the proof**

`snarkJs` uses verification_key.json, proof.json and public.json to verify that is valid. To verify the proof run the following command:

```bash
snarkjs verify -c pedersen.json 
OK
```
`OK` means that the proof is a valid proof ;) 

**Generate the solidity verifier**

This below command will take the `verification_key.json` and generate a solidity code in `verifier.sol` file.

```bash
snarkjs generateverifier -c pedersen.json
```

Deploy the [verifier.sol](pedersen/verifier.sol) using [remix] on any Ethereum Blockchain.

**Verifying the proof on-chain**

Use the generated inputs to call `verifyProof` function in the deployed contract:
```bash
snarkjs generatecall -c pedersen.json 
["0x09c87b4a32ab5ecc67d487fb9753c91e26567831985a6b4d7ea87121e33d5c47", "0x2a796e381e9eb6dd6e573a1c4d00a7aab63fa0c4227d8c5ef5de8ea63ff89a9c"],["0x0292d4794c9532562cbbf9b74388931c3bc15ae9a8431df486e6530ea800c97f", "0x1a04c454e670ff95cf30eb403c9f1f510a856fa9dfcc335d345b904fd1f1e5f4"],[["0x283ecbdde43231693a630a79a4acffad7c0fd7eefdb5cc93794f5534d4649123", "0x047aa3fca3dc16e13425bb2ee789287270fd482b90756f6b43db5033812d0a74"],["0x2f42c207e71232b7351f1d1607a279eb1c6769be1b0361e725092a54ba1ea552", "0x195687ee6923e45d4bb5ef5ca43beca33b52ef1876138cb92ef5215fa03a5d39"]],["0x175b5aab87dbeff0620cbfe0b190b72369fe9e368acca1800ff7d2c4608c9458", "0x20e5b74c426d5ac62c4d494a0a498fc9c131ac941fa31817b5d797ea11b955c7"],["0x2560cc05add2f5d954331f11a58749d3f8c3a7f128dbe818288ac51c429014f4", "0x26729455f73571ed4f2b6ce89bc4328d38b9879e7435c468df15fc8778000574"],["0x1db9e1d238a745ffd336788e9554f3eda3c9133b2203f729aee0198f3dcdd97c", "0x1f816fc9a48d03d47fe59a882dbfe8f0d5837ba3865bbb0608cf0508ac1900c7"],["0x095892926132d35136e19eebca2e024ef356caf8f81c03d1b21442e58eebaf26", "0x0b635b6d77e89cbd3dcd76063513df23023f4525cba34c30574ebe12b8a2ea71"],["0x21bcb58c6e29a7453afa0a77dd85e0805c906f64c90b23deb197eb5f0cf2f987", "0x1361740d118d23e682ddf3cdc0863aa674432c69a026ebff7c84b4c933ba31a6"],["0x088e425bcd5d0ea1294da0ff4058aca616482199f5176b0e7345567515cc0e2a","0x23cfc0b0b403ede9e171833b31bbdbc02adcc37eadf4c5038c133dc06c50273b","0x000000000000000000000000000000000000000000000000000000000000007b","0x000000000000000000000000000000000000000000000000000000000000007b","0x000000000000000000000000000000000000000000000000000000000000007b"]
```

It should return `true`. If you just change any bit in the parameters, you can check that the result will be false.